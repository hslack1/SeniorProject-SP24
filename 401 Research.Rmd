---
title: "401 Research"
author: "Holston Slack"
date: "2/29/2024"
output: html_document
---
```{r}
library (readr)
library(dplyr)
library(ggplot2)
library(stringr)
library(gridExtra)
library(data.table)
library(patchwork)
library(tidyverse)
library(jsonlite)
```

```{r}
credits <- read.csv("credits.csv")
keywords <- read.csv("keywords.csv")
ratings <- read.csv ("ratings.csv")
links <- read.csv("links.csv")
sequels <- read.csv("movies_metadata.csv")
```

```{r}
#merges 2 datasets and joins based off common column
df_combined <- merge(ratings, links, by = "movieId")
```

```{r}
meta <- read.csv("movies_metadata.csv")
meta <- meta %>%
  filter(original_language == "en") %>% 
  filter(as.numeric(str_sub(release_date, 1, 4)) >= 1970 & 
         as.numeric(str_sub(release_date, 1, 4)) <= 2020)%>%
  filter(revenue >= 100) %>%
  filter(budget >=100)

nonsequels <- meta %>%
  filter(is.na(meta$belongs_to_collection) | nchar(meta$belongs_to_collection) == 0) 

sequels <- meta %>%
  filter(str_detect(belongs_to_collection, "\\{"))

sequels <- sequels %>% 
  rename(tmdbId = id)
```


```{r}
df_combined <- merge(df_combined, sequels, by = "tmdbId")
```


```{r}
df_combined <- df_combined %>%
  filter(original_language == "en") %>% 
  filter(as.numeric(str_sub(release_date, 1, 4)) >= 1970 & 
         as.numeric(str_sub(release_date, 1, 4)) <= 2020)
```

Working to regex the title from belongs_to column; string; incomplete

```{r}
extract_between_commas <- function(text) {
  # Split the text by commas using str_split
  split_text <- str_split(text, ",")[[1]]  # Split text, take the first element (vector of substrings)
  
  # Check if there are at least 3 commas (ensure enough elements for 2nd and 3rd comma)
  if (length(split_text) >= 3) {
    # Return the text between 2nd and 3rd comma (excluding commas)
    return(split_text[2])
  } else {
    # If there are less than 3 commas, return an empty string
    return("")
  }
}

# Apply the function to the "text_column"
sequels$franchise <- lapply(sequels$belongs_to_collection, extract_between_commas)

# Assuming your data is in a data frame named 'data' and the column with text is named 'text_column'
```

```{r}
# Function to extract text between 3rd and 4th apostrophes
extract_between_apostrophes <- function(text) {
  # Split the text by apostrophes using str_split
  split_text <- str_split(text, "'")[[1]]  # Split text, take the first element (vector of substrings)
  
  # Check if there are at least 4 apostrophes (ensure enough elements for 3rd and 4th)
  if (length(split_text) >= 5) {
    # Extract the text between 3rd and 4th apostrophe (excluding apostrophes)
    extracted_text <- split_text[4]
    
    # Remove "collection" (case-insensitive) if it exists at the end
    extracted_text <- str_trim(extracted_text, side = "right")  # Remove trailing whitespace
    extracted_text <- gsub(" collection$", "", extracted_text, ignore.case = TRUE)  # Remove " collection" at the end (case-insensitive)
    
    return(extracted_text)
  } else {
    # If there are less than 4 apostrophes, return an empty string
    return("")
  }
}

# Apply the function to the "text_column"
sequels$belongs_to_collection <- lapply(sequels$franchise, extract_between_apostrophes)

sequels <- sequels[, !(colnames(sequels) %in% c("timestamp","lanchise","franchise", "collection"))]

```


```{r}
data <- sequels$genres

# Regular expression to capture characters after 20th position (inclusive) until next '
pattern <- "(?<=.{20})([^']+)"

captured_letters <- character()  # Initialize empty character vector

for (i in 1:length(data)) {
  # Extract text for each element (string) in the vector
  current_letters <- str_extract_all(data[i], pattern) %>% unlist()
  captured_letters <- c(captured_letters, current_letters)  # Append extracted letters
}

# Remove empty strings (optional)
captured_letters <- captured_letters[!captured_letters == ""]
view(captured_letters)
```

```{r}
nonsequels <- nonsequels[, !(colnames(sequels) %in% c("timestamp", "adult", "homepage", "poster_path", "spoken_languages", "status", "tagline", "video", "imdb_id", "overview"))]

sequels <- sequels[, !(colnames(sequels) %in% c("timestamp", "adult", "homepage", "poster_path", "spoken_languages", "status", "tagline", "video", "imdb_id", "overview"))]
```


```{r}
data_type <- typeof(sequels$budget)

if (data_type != "numeric") {
  sequels$revenue <- as.numeric(sequels$revenue)
}
seqfig1 <- ggplot(sequels, aes(x = revenue)) +
  geom_histogram(binwidth = 250000000, fill = "lightblue", color = "black") +  # Adjust binwidth
  theme_minimal() +
  labs(title = "Fig. 1 Distribution of Revenue Amongst Sequels", x = "Revenue (M)", y = "Frequency") +
  scale_x_continuous(breaks = seq(0, 3e9, by = 2.5e+8),  # Labels every 500 million
                     labels = scales::number_format(scale = 1e-6, suffix = "M"))  # Format as
seqfig1


# If it's not numeric, convert it (assuming it's a character vector containing numbers)
if (data_type != "numeric") {
  sequels$budget <- as.numeric(sequels$budget)
}
seqfig2 <- ggplot(sequels, aes(x = budget)) +
  geom_histogram(binwidth = 50000000, fill = "lightblue", color = "black") +  # Adjust binwidth as needed
  theme_minimal() +
  labs(title = "Fig 2. Distribution of Budget Amongst Sequels", x = "Budget (M)", y = "Frequency")+
  scale_x_continuous(breaks = seq(0, 380e6, by = 50e6),  # Labels every 50 million
                   labels = scales::number_format(scale = 1e-6, suffix = "M"))  # Format as millions

seqfig2
```


```{r}
data_type <- typeof(nonsequels$budget)

if (data_type != "numeric") {
  nonsequels$revenue <- as.numeric(nonsequels$revenue)
}
fig1 <- ggplot(nonsequels, aes(x = revenue)) +
  geom_histogram(binwidth = 250000000, fill = "lightblue", color = "black") +  # Adjust binwidth
  theme_minimal() +
  labs(title = "Fig. 2 Distribution of Revenue Amongst Non-Sequels", x = "Revenue (M)", y = "Frequency") +
  scale_x_continuous(breaks = seq(0, 3e9, by = 2.5e+8),  # Labels every 500 million
                     labels = scales::number_format(scale = 1e-6, suffix = "M"))  # Format as
fig1


# If it's not numeric, convert it (assuming it's a character vector containing numbers)
if (data_type != "numeric") {
  nonsequels$budget <- as.numeric(nonsequels$budget)
}
fig2 <- ggplot(nonsequels, aes(x = budget)) +
  geom_histogram(binwidth = 50000000, fill = "lightblue", color = "black") +  # Adjust binwidth as needed
  theme_minimal() +
  labs(title = "Distribution of Budget Amongst Non-Sequels", x = "Budget (M)", y = "Frequency")+
  scale_x_continuous(breaks = seq(0, 380e6, by = 50e6),  # Labels every 50 million
                   labels = scales::number_format(scale = 1e-6, suffix = "M"))  # Format as millions

fig2
```


```{r}
seqdist <- grid.arrange(seqfig1, fig1, nrow = 2)
nondist <- grid.arrange(fig1, fig2, nrow = 2)
```

creating variables

number- this variable identifies the number for each movie in the franchise

```{r}
#format the francise so it is not a list
extracted_data <- sapply(sequels$belongs_to_collection, `[[`, 1)  # Assuming first element is relevant
sequels$collection_info <- extracted_data 

```


Add a number for each movie in the franchise

```{r}
sequels <- sequels %>%
  group_by(collection_info) %>%
  mutate(number = rank(release_date))
```

Filter out movies that belonged to a franchise but there was only one movie in the franchise

```{r}
sequels <- sequels %>%
  group_by(collection_info) %>%
  filter(!all(number == 1))  # Filter groups where NOT all numbers are 1
```

```{r}
sub_sequel <- sequels [, c("budget", "runtime", "vote_average", "revenue")]
correlation_matrix <- cor(sub_sequel, use = "pairwise")
print(correlation_matrix)
```

```{r}
shapiro.test(sequels$budget)
```

```{r}
qqdata <- sequels$budget

theoretical_quantiles <- rnorm(length(qqdata), mean(qqdata), sd(qqdata))

qqplot(qqdata, theoretical_quantiles,
       main="Q-Q Plot of Budget Data", 
       ylab="Theoretical Quantiles", xlab="Sample Quantiles")
```


```{r}
if (any(sequels$budget <= 0)) {
  # Add a small constant (adjust as needed)
  data_adjusted <- sequels$budget + 1
} else {
  data_adjusted <- sequels$budget
}

# Apply log transformation (base-10 in this example)
log_data <- log10(data_adjusted)

# Test normality of log-transformed data
shapiro.test(log_data)

logqqdata <- log_data

theoretical_quantiles <- rnorm(length(logqqdata), mean(logqqdata), sd(logqqdata))

qq_log10budget <- qqplot(logqqdata, theoretical_quantiles,
       main="Q-Q Plot of Budget Data", 
       ylab="Theoretical Quantiles", xlab="Sample Quantiles")
```

```{r}
qqdata <- sequels$runtime

theoretical_quantiles <- rnorm(length(qqdata), mean(qqdata), sd(qqdata))

qq_runtime <- qqplot(qqdata, theoretical_quantiles,
       main="Q-Q Plot of Runtime Data", 
       ylab="Theoretical Quantiles", xlab="Sample Quantiles")
```

```{r}
qqdata <- sequels$vote_average

theoretical_quantiles <- rnorm(length(qqdata), mean(qqdata), sd(qqdata))

qq_vote_avg <- qqplot(qqdata, theoretical_quantiles,
       main="Q-Q Plot of Vote Average", 
       ylab="Theoretical Quantiles", xlab="Sample Quantiles")

```

```{r}
if (!require("gridExtra")) install.packages("gridExtra")
library(gridExtra)

if (any(sequels$number <= 0)) {
  # Add a small constant (adjust as needed)
  data_adjusted <- sequels$budget + 1
} else {
  data_adjusted <- sequels$budget
}

# Apply log transformation (base-10 in this example)
lognumber <- log10(data_adjusted)

# Test normality of log-transformed data
shapiro.test(lognumber)


qq_numberdata <- lognumber

theoretical_quantiles <- rnorm(length(qq_numberdata), mean(qq_numberdata), sd(qq_numberdata))

qq_number <- qqplot(qq_numberdata, theoretical_quantiles,
       main="Q-Q Plot of Movie Number", 
       ylab="Theoretical Quantiles", xlab="Sample Quantiles")
```

```{r}
sequels$log_data <- log_data
sequels$log_number <- lognumber
```

```{r}
lm_model <- lm(revenue ~ log_data + log_number + vote_average + runtime, data = sequels)
summary(lm_model)
```

```{r}
new_min <- 0  # Adjust this value as needed (minimum vote average)
new_max <- 10  # Adjust this value as needed (maximum vote average)

sequelvote <- ggplot(sequels, aes(x = vote_average)) +
  geom_density(alpha = 0.5) +
  labs(title = "Density Plot of Vote Average (Sequels)", x = "Vote Average", y = "Density") +
  theme_grey() +
  scale_x_continuous(limits = c(new_min, new_max))  # Set new limits

nonsequelvote <- ggplot(nonsequels, aes(x = vote_average)) +
  geom_density(alpha = 0.5) +
  labs(title = "Density Plot of Vote Average (Non-Sequels)", x = "Vote Average", y = "Density") +
  theme_grey() +
  scale_x_continuous(limits = c(new_min, new_max))  # Set the same limits again



densityplots <- grid.arrange(sequelvote,nonsequelvote, nrow = 2)
```

